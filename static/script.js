// Naeilum UI scripts with all features

const stepOrder = ['welcome-screen', 'name-input-screen', 'selection-screen', 'result-screen', 'fortune-screen'];
const screenTitles = {
  'welcome-screen': 'Start',
  'name-input-screen': 'Tell Us About You',
  'selection-screen': 'Choose Name',
  'result-screen': 'Your Name',
  'fortune-screen': 'Daily Fortune'
};

let screenHistory = [];
let currentData = {
  originalName: '',
  gender: 'male',
  recommendations: [],
  selectedName: null,
  fortune: []
};

/* ==== FAVORITES & HISTORY (localStorage) ==== */

function getFavorites() {
  try {
    return JSON.parse(localStorage.getItem('naeilum_favorites') || '[]');
  } catch { return []; }
}

function saveFavorites(favorites) {
  localStorage.setItem('naeilum_favorites', JSON.stringify(favorites));
}

function addToFavorites(nameData) {
  const favorites = getFavorites();
  const exists = favorites.some(f => f.name === nameData.name && f.hanja === nameData.hanja);
  if (!exists) {
    favorites.unshift({ ...nameData, savedAt: new Date().toISOString() });
    saveFavorites(favorites);
    showToast('Added to favorites ‚≠ê');
    return true;
  }
  showToast('Already in favorites');
  return false;
}

function removeFromFavorites(nameData) {
  let favorites = getFavorites();
  favorites = favorites.filter(f => !(f.name === nameData.name && f.hanja === nameData.hanja));
  saveFavorites(favorites);
  showToast('Removed from favorites');
}

function isFavorite(nameData) {
  const favorites = getFavorites();
  return favorites.some(f => f.name === nameData.name && f.hanja === nameData.hanja);
}

function getNameHistory() {
  try {
    return JSON.parse(localStorage.getItem('naeilum_history') || '[]');
  } catch { return []; }
}

function saveToHistory(nameData, originalName) {
  const history = getNameHistory();
  history.unshift({
    ...nameData,
    originalName,
    selectedAt: new Date().toISOString()
  });
  // Keep last 20
  if (history.length > 20) history.pop();
  localStorage.setItem('naeilum_history', JSON.stringify(history));
}

/* ==== SHARING ==== */

async function shareName(nameData) {
  const romanization = Array.isArray(nameData.romanization) 
    ? nameData.romanization.join(' / ') 
    : nameData.romanization || '';

  const shareText = `My Korean name: ${nameData.name} (${nameData.hanja})
${romanization ? 'Romanization: ' + romanization + '\n' : ''}Meaning: ${nameData.meaning}
Category: ${nameData.category}

- Generated by Naeilum üåø
${window.location.href}`;

  if (navigator.share) {
    try {
      await navigator.share({ 
        title: 'My Korean Name - Naeilum', 
        text: shareText,
        url: window.location.href
      });
      showToast('Shared successfully!');
    } catch (e) {
      if (e.name !== 'AbortError') copyToClipboard(shareText);
    }
  } else {
    copyToClipboard(shareText);
  }
}

function copyToClipboard(text) {
  navigator.clipboard.writeText(text).then(() => {
    showToast('Copied to clipboard üìã');
  }).catch(() => {
    showToast('Failed to copy');
  });
}

/* ==== IMAGE SAVE ==== */

async function saveResultAsImage() {
  const resultCard = document.querySelector('#result-screen .result-card');
  if (!resultCard) {
    showToast('Nothing to save');
    return;
  }

  showToast('Generating image...');

  try {
    // Use html2canvas if available, otherwise create a simple canvas
    if (typeof html2canvas !== 'undefined') {
      const canvas = await html2canvas(resultCard, {
        backgroundColor: '#FAF9F7',
        scale: 2,
        useCORS: true
      });
      downloadCanvas(canvas, `naeilum-${currentData.selectedName?.name || 'name'}.png`);
    } else {
      // Fallback: Create a styled canvas manually
      await createResultImage();
    }
  } catch (error) {
    console.error('Image save error:', error);
    showToast('Failed to save image');
  }
}

async function createResultImage() {
  const nameData = currentData.selectedName;
  if (!nameData) return;

  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  // Set canvas size
  canvas.width = 600;
  canvas.height = 800;

  // Background
  ctx.fillStyle = '#FAF9F7';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Card background
  ctx.fillStyle = '#FFFFFF';
  roundRect(ctx, 40, 40, 520, 720, 20);
  ctx.fill();

  // Shadow effect
  ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
  ctx.shadowBlur = 20;
  ctx.shadowOffsetY = 4;

  // Korean name
  ctx.shadowColor = 'transparent';
  ctx.fillStyle = '#234B7A';
  ctx.font = 'bold 72px "Noto Sans KR", sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(nameData.name, canvas.width / 2, 180);

  // Hanja
  ctx.fillStyle = '#666666';
  ctx.font = '32px "Noto Sans KR", serif';
  ctx.fillText(nameData.hanja, canvas.width / 2, 240);

  // Romanization
  const romanization = Array.isArray(nameData.romanization) 
    ? nameData.romanization.join(' / ') 
    : (nameData.romanization || '');
  if (romanization) {
    ctx.fillStyle = '#6C8CC9';
    ctx.font = '24px "Noto Sans KR", sans-serif';
    ctx.fillText(romanization, canvas.width / 2, 290);
  }

  // Meaning label
  ctx.fillStyle = '#BD6B5F';
  ctx.font = '16px sans-serif';
  ctx.fillText('MEANING', canvas.width / 2, 360);

  // Meaning text
  ctx.fillStyle = '#333333';
  ctx.font = '20px "Noto Sans KR", sans-serif';
  wrapText(ctx, nameData.meaning, canvas.width / 2, 400, 440, 28);

  // Category
  ctx.fillStyle = '#666666';
  ctx.font = '18px sans-serif';
  ctx.fillText(`Category: ${nameData.category}`, canvas.width / 2, 500);

  // Original name
  ctx.fillStyle = '#999999';
  ctx.font = '16px sans-serif';
  ctx.fillText(`Korean name for: ${currentData.originalName}`, canvas.width / 2, 620);

  // Branding
  ctx.fillStyle = '#234B7A';
  ctx.font = 'bold 18px sans-serif';
  ctx.fillText('Naeilum üåø', canvas.width / 2, 700);

  downloadCanvas(canvas, `naeilum-${nameData.name}.png`);
  showToast('Image saved! üì∑');
}

function roundRect(ctx, x, y, width, height, radius) {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
}

function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
  const words = text.split(' ');
  let line = '';
  let testY = y;

  for (let n = 0; n < words.length; n++) {
    const testLine = line + words[n] + ' ';
    const metrics = ctx.measureText(testLine);
    if (metrics.width > maxWidth && n > 0) {
      ctx.fillText(line, x, testY);
      line = words[n] + ' ';
      testY += lineHeight;
    } else {
      line = testLine;
    }
  }
  ctx.fillText(line, x, testY);
}

function downloadCanvas(canvas, filename) {
  const link = document.createElement('a');
  link.download = filename;
  link.href = canvas.toDataURL('image/png');
  link.click();
}

/* ==== PRONUNCIATION (Web Speech API) ==== */

function pronounceName(name) {
  if (!('speechSynthesis' in window)) {
    showToast('Speech not supported');
    return;
  }

  window.speechSynthesis.cancel();
  const utterance = new SpeechSynthesisUtterance(name);
  utterance.lang = 'ko-KR';
  utterance.rate = 0.8;

  const voices = window.speechSynthesis.getVoices();
  const koreanVoice = voices.find(v => v.lang.startsWith('ko'));
  if (koreanVoice) utterance.voice = koreanVoice;

  window.speechSynthesis.speak(utterance);
}

/* ==== NAME VALIDATION ==== */

function isValidName(name) {
  if (!name || name.length < 2) {
    return { valid: false, message: 'Name must be at least 2 characters.' };
  }
  if (name.length > 100) {
    return { valid: false, message: 'Name is too long (100 chars max).' };
  }
  if (/^[0-9]+$/.test(name)) {
    return { valid: false, message: 'Name cannot be only numbers.' };
  }
  if (/^[^a-zA-ZÍ∞Ä-Ìû£„ÅÅ-„Çì„Ç°-„É≥‰∏Ä-ÈæØ]+$/.test(name)) {
    return { valid: false, message: 'Name must contain letters.' };
  }
  const letterCount = (name.match(/[a-zA-ZÍ∞Ä-Ìû£„ÅÅ-„Çì„Ç°-„É≥‰∏Ä-ÈæØ]/g) || []).length;
  if (letterCount < 2) {
    return { valid: false, message: 'Name must have at least 2 letters.' };
  }
  return { valid: true };
}

/* ==== CSRF + Fetch helpers ==== */

let CSRF_TOKEN = null;

async function fetchCsrfToken() {
  try {
    const res = await fetch('/api/csrf_token', { credentials: 'same-origin' });
    const data = await res.json();
    if (data?.success && data?.token) CSRF_TOKEN = data.token;
  } catch (e) {
    console.warn('Failed to fetch CSRF token', e);
  }
}

async function postJSON(url, body = {}, options = { retryOnCsrf: true }) {
  if (!CSRF_TOKEN) await fetchCsrfToken();
  const headers = { 'Content-Type': 'application/json' };
  if (CSRF_TOKEN) headers['X-CSRF-Token'] = CSRF_TOKEN;

  const res = await fetch(url, {
    method: 'POST',
    headers,
    body: JSON.stringify(body),
    credentials: 'same-origin'
  });

  let payload = null;
  try { payload = await res.json(); } catch {}

  const failed = !res.ok || (payload && payload.success === false);
  const csrfFailed = res.status === 403 && (payload?.error?.code === 'CSRF_FAILED');

  if (csrfFailed && options.retryOnCsrf) {
    CSRF_TOKEN = null;
    await fetchCsrfToken();
    return postJSON(url, body, { retryOnCsrf: false });
  }

  if (failed) {
    const msg = payload?.error?.message || res.statusText || 'Request failed';
    throw new Error(msg);
  }

  return payload ?? { success: true };
}

/* ==== Theme helpers ==== */

function applyTheme(theme) {
  const root = document.documentElement;
  if (theme === 'system') {
    root.removeAttribute('data-theme');
  } else {
    root.setAttribute('data-theme', theme);
  }
}

async function initTheme() {
  try {
    const res = await fetch('/api/theme', { credentials: 'same-origin' });
    const data = await res.json();
    if (data?.success && data.theme) applyTheme(data.theme);
  } catch {}
}

async function toggleTheme() {
  try {
    const data = await postJSON('/api/theme/toggle', {});
    if (data?.success && data.theme) {
      applyTheme(data.theme);
      showToast(`Theme: ${data.theme}`);
    } else {
      throw new Error(data?.error?.message || 'Theme toggle failed');
    }
  } catch (e) {
    console.error('Theme toggle failed:', e);
    showToast(e?.message || 'Theme toggle failed');
  }
}

function setupThemeToggle() {
  const welcome = document.getElementById('welcome-screen');
  if (!welcome) return;

  const legacy = document.querySelector('body > .theme-toggle');
  if (legacy) legacy.remove();

  let btn = welcome.querySelector('.theme-toggle');
  if (!btn) {
    btn = document.createElement('button');
    btn.className = 'theme-toggle theme-toggle--welcome';
    btn.type = 'button';
    btn.textContent = 'Toggle Theme';

    const footerLinks = welcome.querySelector('.footer-links');
    if (footerLinks) {
      welcome.insertBefore(btn, footerLinks);
    } else {
      welcome.appendChild(btn);
    }
  }
  btn.addEventListener('click', toggleTheme);
}

function updateThemeToggleVisibility(activeScreenId) {
  const btn = document.querySelector('#welcome-screen .theme-toggle');
  if (!btn) return;
  btn.style.display = (activeScreenId === 'welcome-screen') ? '' : 'none';
}

/* ==== Boot ==== */

document.addEventListener('DOMContentLoaded', async () => {
  injectProgressRail();
  injectToast();
  await initTheme();
  setupThemeToggle();

  // Load voices for pronunciation
  if ('speechSynthesis' in window) {
    speechSynthesis.getVoices();
  }

  screenHistory = ['welcome-screen'];
  showScreen('welcome-screen', { skipHistory: true });

  const getStartedBtn = document.getElementById('get-started-btn');
  if (getStartedBtn) {
    getStartedBtn.addEventListener('click', event => {
      event.preventDefault();
      showNameInput();
    });
  }

  const nameForm = document.getElementById('name-form');
  if (nameForm) {
    nameForm.addEventListener('submit', handleNameSubmit);
  }

  const dateElement = document.getElementById('fortune-date');
  if (dateElement) {
    const today = new Date();
    dateElement.textContent = today.toLocaleDateString('en-US', {
      weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
    });
  }
});

/* ==== Screen navigation ==== */

function showScreen(screenId, options = {}) {
  const { skipHistory = false } = options;

  document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));

  const targetScreen = document.getElementById(screenId);
  if (!targetScreen) return;

  targetScreen.classList.add('active');

  if (!skipHistory && screenHistory[screenHistory.length - 1] !== screenId) {
    screenHistory.push(screenId);
  }

  updateProgressRail(screenId);
  focusFirstField(screenId);

  if (screenId === 'selection-screen') {
    attachCardEnhancements();
  }
  updateThemeToggleVisibility(screenId);
}

function goBack(targetScreenId) {
  if (screenHistory.length > 1) {
    screenHistory.pop();
  }

  if (targetScreenId) {
    showScreen(targetScreenId, { skipHistory: true });
    screenHistory = screenHistory.filter(screen => screen !== targetScreenId);
    screenHistory.push(targetScreenId);
  } else if (screenHistory.length > 0) {
    showScreen(screenHistory[screenHistory.length - 1], { skipHistory: true });
  }
}

function showNameInput() {
  showScreen('name-input-screen');
}

/* ==== Form handling with validation ==== */

async function handleNameSubmit(event) {
  event.preventDefault();

  const nameInput = document.getElementById('name');
  const genderInput = document.querySelector('input[name="gender"]:checked');

  if (!nameInput || !genderInput) {
    showToast('Please enter your name and select a gender.');
    return;
  }

  const name = nameInput.value.trim();
  const gender = genderInput.value;

  // Name validation
  const validation = isValidName(name);
  if (!validation.valid) {
    showToast(validation.message);
    return;
  }

  currentData.originalName = name;
  currentData.gender = gender;

  showLoading(true);

  try {
    const data = await postJSON('/recommend', { name, gender });

    if (data.success) {
      currentData.recommendations = data.names;
      displayNameCards(data.names);
      showScreen('selection-screen');
      showToast('Recommendations ready ‚ú®');
    } else {
      const errMsg = data.error?.message || data.error || 'Failed to get recommendations.';
      showToast(`Error: ${errMsg}`);
    }
  } catch (error) {
    console.error('Recommendation error:', error);
    showToast('Connection issue ‚Äì please try again.');
  } finally {
    showLoading(false);
  }
}

/* ==== Name selection with romanization ==== */

function displayNameCards(names) {
  const container = document.getElementById('name-cards');
  if (!container) return;

  container.innerHTML = '';

  const categoryPalette = {
    Strength: '#234B7A',
    Light: '#6C8CC9',
    Honor: '#BD6B5F',
    Wisdom: '#4E6FA6',
    Justice: '#233A58',
    Love: '#C27A7A',
    Harmony: '#3A8570',
    Prosperity: '#C9A86A'
  };

  names.forEach((nameData, index) => {
    const card = document.createElement('div');
    card.className = 'name-card';
    card.dataset.index = index;

    card.setAttribute('role', 'button');
    card.setAttribute('aria-selected', 'false');
    card.setAttribute('aria-label', `${nameData.name} ‚Äì ${nameData.category}`);

    const categoryColor = categoryPalette[nameData.category] || '#234B7A';

    // Romanization display
    const romanization = Array.isArray(nameData.romanization) 
      ? nameData.romanization.join(' / ') 
      : (nameData.romanization || '');

    const romanizationHtml = romanization 
      ? `<span class="name-romanization">${romanization}</span>` 
      : '';

    card.innerHTML = `
      <div class="name-card-header">
        <div class="name-info">
          <span class="korean-name">${nameData.name}</span>
          <span class="hanja">${nameData.hanja}</span>
          ${romanizationHtml}
        </div>
        <button class="btn-icon btn-pronounce" title="Hear pronunciation" onclick="event.stopPropagation(); pronounceName('${nameData.name}')">üîä</button>
      </div>
      <div class="name-meaning">${nameData.meaning}</div>
      <span class="name-category-badge" style="color:${categoryColor}; border-color:${categoryColor}33; background:${categoryColor}14;">
        ${nameData.category}
      </span>
    `;

    card.addEventListener('click', event => {
      createRipple(event, card);
      selectName(index);
    });

    container.appendChild(card);
  });
}

async function selectName(index) {
  if (index >= currentData.recommendations.length) return;

  highlightSelectedCard(index);
  currentData.selectedName = currentData.recommendations[index];

  // Save to history
  saveToHistory(currentData.selectedName, currentData.originalName);

  showLoading(true);

  try {
    const data = await postJSON('/select', { index });

    if (data.success) {
      currentData.fortune = data.fortune;
      displayResult(currentData.selectedName);
      showScreen('result-screen');
      showToast('Name locked in! üåø');
    } else {
      const errMsg = data.error?.message || data.error || 'Failed to process selection.';
      showToast(`Error: ${errMsg}`);
    }
  } catch (error) {
    console.error('Selection error:', error);
    showToast('Something went wrong. Try again?');
  } finally {
    showLoading(false);
  }
}

function highlightSelectedCard(index) {
  document.querySelectorAll('.name-card').forEach(card => {
    card.classList.remove('selected');
    card.setAttribute('aria-selected', 'false');
  });
  const selectedCard = document.querySelector(`.name-card[data-index="${index}"]`);
  if (selectedCard) {
    selectedCard.classList.add('selected');
    selectedCard.setAttribute('aria-selected', 'true');
  }
}

function displayResult(nameData) {
  const nameLarge = document.getElementById('korean-name-large');
  const nameHanja = document.getElementById('korean-name-hanja');
  const nameRomanization = document.getElementById('korean-name-romanization');
  const meaningText = document.getElementById('name-meaning-text');
  const categoryText = document.getElementById('name-category');
  const originalName = document.getElementById('original-name-display');

  if (nameLarge) nameLarge.textContent = nameData.name;
  if (nameHanja) nameHanja.textContent = nameData.hanja;
  if (meaningText) meaningText.textContent = nameData.meaning;
  if (categoryText) categoryText.textContent = nameData.category;
  if (originalName) originalName.textContent = currentData.originalName;

  // Romanization
  if (nameRomanization) {
    const romanization = Array.isArray(nameData.romanization) 
      ? nameData.romanization.join(' / ') 
      : (nameData.romanization || '');
    nameRomanization.textContent = romanization;
  }

  // Setup action buttons for result screen
  setupResultActions(nameData);
}

function setupResultActions(nameData) {
  // Find or create the action buttons container
  let actionsContainer = document.querySelector('#result-screen .result-card-actions');

  if (!actionsContainer) {
    // Create new actions container inside result card
    const resultCard = document.querySelector('#result-screen .result-card');
    if (resultCard) {
      actionsContainer = document.createElement('div');
      actionsContainer.className = 'result-card-actions';

      // Insert before the footer (original name display)
      const footer = resultCard.querySelector('.result-card-footer');
      if (footer) {
        resultCard.insertBefore(actionsContainer, footer);
      } else {
        resultCard.appendChild(actionsContainer);
      }
    }
  }

  if (actionsContainer) {
    const isFav = isFavorite(nameData);

    actionsContainer.innerHTML = `
      <button class="btn-action btn-favorite" onclick="toggleFavorite()">
        <span class="btn-action-icon">${isFav ? '‚≠ê' : '‚òÜ'}</span>
        <span class="btn-action-text">${isFav ? 'Favorited' : 'Favorite'}</span>
      </button>
      <button class="btn-action btn-share" onclick="shareName(currentData.selectedName)">
        <span class="btn-action-icon">üì§</span>
        <span class="btn-action-text">Share</span>
      </button>
      <button class="btn-action btn-pronounce-result" onclick="pronounceName(currentData.selectedName.name)">
        <span class="btn-action-icon">üîä</span>
        <span class="btn-action-text">Pronounce</span>
      </button>
      <button class="btn-action btn-save-image" onclick="saveResultAsImage()">
        <span class="btn-action-icon">üì∑</span>
        <span class="btn-action-text">Save Image</span>
      </button>
    `;
  }
}

function toggleFavorite() {
  const nameData = currentData.selectedName;
  if (!nameData) return;

  if (isFavorite(nameData)) {
    removeFromFavorites(nameData);
  } else {
    addToFavorites(nameData);
  }
  setupResultActions(nameData);
}

function updateResultButtons(nameData) {
  // Legacy function - now handled by setupResultActions
  setupResultActions(nameData);
}

/* ==== Fortune flow with Korean support ==== */

function showFortune() {
  if (currentData.fortune && currentData.fortune.length > 0) {
    displayFortune(currentData.fortune);
    showScreen('fortune-screen');
    showToast('Daily fortune revealed ‚òÄÔ∏è');
  }
}

function displayFortune(fortunes) {
  const container = document.getElementById('fortune-cards');
  if (!container) return;

  container.innerHTML = '';

  const fortuneStyles = {
    Love: { color: '#BD6B5F', icon: '‚ô•' },
    Career: { color: '#234B7A', icon: 'üíº' },
    Wealth: { color: '#C9A86A', icon: '‚óÜ' },
    Health: { color: '#3A8570', icon: '‚úß' },
    Wisdom: { color: '#4E6FA6', icon: '‚ú¶' },
    Family: { color: '#6C8CC9', icon: 'üè†' },
    Friendship: { color: '#C27A7A', icon: 'ü§ù' },
    Travel: { color: '#3A8570', icon: '‚úàÔ∏è' },
    Creativity: { color: '#BD6B5F', icon: 'üé®' },
    Luck: { color: '#C9A86A', icon: 'üçÄ' }
  };

  fortunes.forEach(fortune => {
    const style = fortuneStyles[fortune.category] || { color: '#234B7A', icon: '‚ú∂' };
    const card = document.createElement('div');
    card.className = 'fortune-card';
    card.style.borderLeft = `4px solid ${style.color}`;

    // Handle message object (en/ko) or string
    let messageEn = '';
    let messageKo = '';

    if (typeof fortune.message === 'object' && fortune.message !== null) {
      messageEn = fortune.message.en || '';
      messageKo = fortune.message.ko || '';
    } else {
      messageEn = fortune.message || '';
    }

    // Category display (English + Korean if available)
    const categoryDisplay = fortune.category_ko 
      ? `${fortune.category} / ${fortune.category_ko}`
      : fortune.category;

    card.innerHTML = `
      <div class="fortune-category" style="color:${style.color}">
        ${style.icon} ${categoryDisplay}
      </div>
      <div class="fortune-message">${messageEn}</div>
      ${messageKo ? `<div class="fortune-message-ko">${messageKo}</div>` : ''}
    `;

    container.appendChild(card);
  });
}

/* ==== Reset ==== */

function startOver() {
  currentData = {
    originalName: '',
    gender: 'male',
    recommendations: [],
    selectedName: null,
    fortune: []
  };

  const nameInput = document.getElementById('name');
  if (nameInput) nameInput.value = '';

  const maleRadio = document.querySelector('input[name="gender"][value="male"]');
  if (maleRadio) maleRadio.checked = true;

  screenHistory = ['welcome-screen'];
  showScreen('welcome-screen', { skipHistory: true });
  showToast('Reset complete.');
}

/* ==== Utilities ==== */

function showLoading(show) {
  const overlay = document.getElementById('loading-overlay');
  if (!overlay) return;
  overlay.classList.toggle('active', !!show);
}

function createRipple(event, element) {
  const ripple = document.createElement('span');
  ripple.className = 'ripple';
  const rect = element.getBoundingClientRect();
  const size = Math.max(rect.width, rect.height);
  ripple.style.width = ripple.style.height = `${size}px`;

  const hasPointer = typeof event?.clientX === 'number' && typeof event?.clientY === 'number' && (event.clientX !== 0 || event.clientY !== 0);
  const left = hasPointer ? (event.clientX - rect.left - size / 2) : (rect.width / 2 - size / 2);
  const top = hasPointer ? (event.clientY - rect.top - size / 2) : (rect.height / 2 - size / 2);

  ripple.style.left = `${left}px`;
  ripple.style.top = `${top}px`;
  element.appendChild(ripple);
  setTimeout(() => ripple.remove(), 600);
}

function attachCardEnhancements() {
  document.querySelectorAll('.name-card').forEach(card => {
    card.setAttribute('tabindex', '0');
    card.addEventListener('keydown', event => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        card.click();
      }
    });
  });
}

function injectProgressRail() {
  if (document.querySelector('.progress-rail')) return;

  const container = document.querySelector('.container');
  if (!container) return;

  const rail = document.createElement('div');
  rail.className = 'progress-rail';
  rail.id = 'progress-rail';
  rail.setAttribute('role', 'tablist');
  rail.setAttribute('aria-label', 'Onboarding steps');

  stepOrder.forEach(stepId => {
    const stepEl = document.createElement('div');
    stepEl.className = 'progress-step';
    stepEl.dataset.step = stepId;
    stepEl.textContent = screenTitles[stepId];
    rail.appendChild(stepEl);
  });

  container.prepend(rail);
  updateProgressRail('welcome-screen');
}

function updateProgressRail(activeScreenId) {
  document.querySelectorAll('.progress-step').forEach(step => step.classList.remove('active'));
  const activeStep = document.querySelector(`.progress-step[data-step="${activeScreenId}"]`);
  if (activeStep) activeStep.classList.add('active');
}

function focusFirstField(screenId) {
  if (screenId === 'name-input-screen') {
    const input = document.getElementById('name');
    if (input) setTimeout(() => input.focus(), 220);
  }
}

function injectToast() {
  if (document.querySelector('.toast')) return;
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.id = 'toast';
  toast.setAttribute('role', 'status');
  toast.setAttribute('aria-live', 'polite');
  document.body.appendChild(toast);
}

let toastTimeout;
function showToast(message = '') {
  const toast = document.getElementById('toast');
  if (!toast) return;

  toast.textContent = message;
  toast.classList.add('show');
  clearTimeout(toastTimeout);
  toastTimeout = setTimeout(() => toast.classList.remove('show'), 2600);
}

/* Keyboard support */
document.addEventListener('keydown', event => {
  if (event.key === 'Escape') {
    const currentScreen = screenHistory[screenHistory.length - 1];
    const backButton = document.querySelector(`#${currentScreen} .back-button`);
    if (backButton) backButton.click();
  }
});
