// Naeilum UI scripts with all features

const stepOrder = ['welcome-screen', 'name-input-screen', 'selection-screen', 'result-screen', 'fortune-screen'];
const screenTitles = {
  'welcome-screen': 'Start',
  'name-input-screen': 'Tell Us About You',
  'selection-screen': 'Choose Name',
  'result-screen': 'Your Name',
  'fortune-screen': 'Daily Fortune'
};

let screenHistory = [];
let currentData = {
  originalName: '',
  gender: 'male',
  recommendations: [],
  selectedName: null,
  fortune: []
};

// Artificial delay settings (ms) - makes it feel like real analysis
const DELAYS = {
  nameGeneration: 2000,    // 2 seconds for name generation
  fortuneGeneration: 1500, // 1.5 seconds for fortune
  nameSelection: 1200      // 1.2 seconds for name selection
};

// Delay helper function
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/* ==== FAVORITES & HISTORY (localStorage) ==== */

function getFavorites() {
  try {
    return JSON.parse(localStorage.getItem('naeilum_favorites') || '[]');
  } catch { return []; }
}

function saveFavorites(favorites) {
  localStorage.setItem('naeilum_favorites', JSON.stringify(favorites));
}

function addToFavorites(nameData) {
  const favorites = getFavorites();
  const exists = favorites.some(f => f.name === nameData.name && f.hanja === nameData.hanja);
  if (!exists) {
    favorites.unshift({ ...nameData, savedAt: new Date().toISOString() });
    saveFavorites(favorites);
    showToast('Added to favorites ‚≠ê');
    return true;
  }
  showToast('Already in favorites');
  return false;
}

function removeFromFavorites(nameData) {
  let favorites = getFavorites();
  favorites = favorites.filter(f => !(f.name === nameData.name && f.hanja === nameData.hanja));
  saveFavorites(favorites);
  showToast('Removed from favorites');
}

function isFavorite(nameData) {
  const favorites = getFavorites();
  return favorites.some(f => f.name === nameData.name && f.hanja === nameData.hanja);
}

function getNameHistory() {
  try {
    return JSON.parse(localStorage.getItem('naeilum_history') || '[]');
  } catch { return []; }
}

function saveToHistory(nameData, originalName) {
  const history = getNameHistory();
  history.unshift({
    ...nameData,
    originalName,
    selectedAt: new Date().toISOString()
  });
  if (history.length > 20) history.pop();
  localStorage.setItem('naeilum_history', JSON.stringify(history));
}

/* ==== SHARING ==== */

async function shareName(nameData) {
  const romanization = Array.isArray(nameData.romanization) 
    ? nameData.romanization.join(' / ') 
    : nameData.romanization || '';

  const shareText = `My Korean name: ${nameData.name} (${nameData.hanja})${romanization ? '\nRomanization: ' + romanization : ''}\nMeaning: ${nameData.meaning}\nCategory: ${nameData.category}\n\n- Generated by Naeilum üåø`;

  if (navigator.share) {
    try {
      await navigator.share({ title: 'My Korean Name - Naeilum', text: shareText });
      showToast('Shared successfully!');
    } catch (e) {
      if (e.name !== 'AbortError') copyToClipboard(shareText);
    }
  } else {
    copyToClipboard(shareText);
  }
}

function copyToClipboard(text) {
  navigator.clipboard.writeText(text).then(() => {
    showToast('Copied to clipboard üìã');
  }).catch(() => {
    showToast('Failed to copy');
  });
}

/* ==== PRONUNCIATION (Web Speech API) ==== */

function pronounceName(name) {
  if (!('speechSynthesis' in window)) {
    showToast('Speech not supported');
    return;
  }

  window.speechSynthesis.cancel();
  const utterance = new SpeechSynthesisUtterance(name);
  utterance.lang = 'ko-KR';
  utterance.rate = 0.8;

  const voices = window.speechSynthesis.getVoices();
  const koreanVoice = voices.find(v => v.lang.startsWith('ko'));
  if (koreanVoice) utterance.voice = koreanVoice;

  window.speechSynthesis.speak(utterance);
}

/* ==== NAME VALIDATION ==== */

function isValidName(name) {
  if (!name || name.length < 2) {
    return { valid: false, message: 'Name must be at least 2 characters.' };
  }
  if (name.length > 100) {
    return { valid: false, message: 'Name is too long (100 chars max).' };
  }
  if (/^[0-9]+$/.test(name)) {
    return { valid: false, message: 'Name cannot be only numbers.' };
  }
  if (/^[^a-zA-ZÍ∞Ä-Ìû£„ÅÅ-„Çì„Ç°-„É≥‰∏Ä-ÈæØ]+$/.test(name)) {
    return { valid: false, message: 'Name must contain letters.' };
  }
  const letterCount = (name.match(/[a-zA-ZÍ∞Ä-Ìû£„ÅÅ-„Çì„Ç°-„É≥‰∏Ä-ÈæØ]/g) || []).length;
  if (letterCount < 2) {
    return { valid: false, message: 'Name must have at least 2 letters.' };
  }
  return { valid: true };
}

/* ==== CSRF + Fetch helpers ==== */

let CSRF_TOKEN = null;

async function fetchCsrfToken() {
  try {
    const res = await fetch('/api/csrf_token', { credentials: 'same-origin' });
    const data = await res.json();
    if (data?.success && data?.token) CSRF_TOKEN = data.token;
  } catch (e) {
    console.warn('Failed to fetch CSRF token', e);
  }
}

async function postJSON(url, body = {}, options = { retryOnCsrf: true }) {
  if (!CSRF_TOKEN) await fetchCsrfToken();
  const headers = { 'Content-Type': 'application/json' };
  if (CSRF_TOKEN) headers['X-CSRF-Token'] = CSRF_TOKEN;

  const res = await fetch(url, {
    method: 'POST',
    headers,
    body: JSON.stringify(body),
    credentials: 'same-origin'
  });

  let payload = null;
  try { payload = await res.json(); } catch {}

  const failed = !res.ok || (payload && payload.success === false);
  const csrfFailed = res.status === 403 && (payload?.error?.code === 'CSRF_FAILED');

  if (csrfFailed && options.retryOnCsrf) {
    CSRF_TOKEN = null;
    await fetchCsrfToken();
    return postJSON(url, body, { retryOnCsrf: false });
  }

  if (failed) {
    const msg = payload?.error?.message || res.statusText || 'Request failed';
    throw new Error(msg);
  }

  return payload ?? { success: true };
}

/* ==== Theme helpers ==== */

function applyTheme(theme) {
  const root = document.documentElement;
  if (theme === 'system') {
    root.removeAttribute('data-theme');
  } else {
    root.setAttribute('data-theme', theme);
  }
}

async function initTheme() {
  try {
    const res = await fetch('/api/theme', { credentials: 'same-origin' });
    const data = await res.json();
    if (data?.success && data.theme) applyTheme(data.theme);
  } catch {}
}

async function toggleTheme() {
  try {
    const data = await postJSON('/api/theme/toggle', {});
    if (data?.success && data.theme) {
      applyTheme(data.theme);
      showToast(`Theme: ${data.theme}`);
    } else {
      throw new Error(data?.error?.message || 'Theme toggle failed');
    }
  } catch (e) {
    console.error('Theme toggle failed:', e);
    showToast(e?.message || 'Theme toggle failed');
  }
}

function setupThemeToggle() {
  const welcome = document.getElementById('welcome-screen');
  if (!welcome) return;

  const legacy = document.querySelector('body > .theme-toggle');
  if (legacy) legacy.remove();

  let btn = welcome.querySelector('.theme-toggle');
  if (!btn) {
    btn = document.createElement('button');
    btn.className = 'theme-toggle theme-toggle--welcome';
    btn.type = 'button';
    btn.textContent = 'Toggle Theme';

    const footerLinks = welcome.querySelector('.footer-links');
    if (footerLinks) {
      welcome.insertBefore(btn, footerLinks);
    } else {
      welcome.appendChild(btn);
    }
  }
  btn.addEventListener('click', toggleTheme);
}

function updateThemeToggleVisibility(activeScreenId) {
  const btn = document.querySelector('#welcome-screen .theme-toggle');
  if (!btn) return;
  btn.style.display = (activeScreenId === 'welcome-screen') ? '' : 'none';
}

/* ==== Loading with messages ==== */

function injectLoadingOverlay() {
  if (document.getElementById('loading-overlay')) return;

  const overlay = document.createElement('div');
  overlay.id = 'loading-overlay';
  overlay.className = 'loading-overlay';
  overlay.innerHTML = `
    <div class="loading-content">
      <div class="loading-spinner"></div>
      <div class="loading-text" id="loading-text">Loading...</div>
    </div>
  `;
  document.body.appendChild(overlay);
}

function showLoading(show, message = 'Loading...') {
  const overlay = document.getElementById('loading-overlay');
  if (!overlay) return;

  const textEl = document.getElementById('loading-text');
  if (textEl) textEl.textContent = message;

  overlay.classList.toggle('active', !!show);
}

/* ==== Boot ==== */

document.addEventListener('DOMContentLoaded', async () => {
  injectProgressRail();
  injectToast();
  injectLoadingOverlay();
  await initTheme();
  setupThemeToggle();

  if ('speechSynthesis' in window) {
    speechSynthesis.getVoices();
  }

  screenHistory = ['welcome-screen'];
  showScreen('welcome-screen', { skipHistory: true });

  const getStartedBtn = document.getElementById('get-started-btn');
  if (getStartedBtn) {
    getStartedBtn.addEventListener('click', event => {
      event.preventDefault();
      showNameInput();
    });
  }

  const nameForm = document.getElementById('name-form');
  if (nameForm) {
    nameForm.addEventListener('submit', handleNameSubmit);
  }

  const dateElement = document.getElementById('fortune-date');
  if (dateElement) {
    const today = new Date();
    dateElement.textContent = today.toLocaleDateString('en-US', {
      weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
    });
  }
});

/* ==== Screen navigation ==== */

function showScreen(screenId, options = {}) {
  const { skipHistory = false } = options;

  document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));

  const targetScreen = document.getElementById(screenId);
  if (!targetScreen) return;

  targetScreen.classList.add('active');

  if (!skipHistory && screenHistory[screenHistory.length - 1] !== screenId) {
    screenHistory.push(screenId);
  }

  updateProgressRail(screenId);
  focusFirstField(screenId);

  if (screenId === 'selection-screen') {
    attachCardEnhancements();
  }
  updateThemeToggleVisibility(screenId);
}

function goBack(targetScreenId) {
  if (screenHistory.length > 1) {
    screenHistory.pop();
  }

  if (targetScreenId) {
    showScreen(targetScreenId, { skipHistory: true });
    screenHistory = screenHistory.filter(screen => screen !== targetScreenId);
    screenHistory.push(targetScreenId);
  } else if (screenHistory.length > 0) {
    showScreen(screenHistory[screenHistory.length - 1], { skipHistory: true });
  }
}

function showNameInput() {
  showScreen('name-input-screen');
}

/* ==== Form handling with validation + DELAY ==== */

async function handleNameSubmit(event) {
  event.preventDefault();

  const nameInput = document.getElementById('name');
  const genderInput = document.querySelector('input[name="gender"]:checked');

  if (!nameInput || !genderInput) {
    showToast('Please enter your name and select a gender.');
    return;
  }

  const name = nameInput.value.trim();
  const gender = genderInput.value;

  const validation = isValidName(name);
  if (!validation.valid) {
    showToast(validation.message);
    return;
  }

  currentData.originalName = name;
  currentData.gender = gender;

  // Show loading with custom message
  showLoading(true, 'Analyzing your name...');

  try {
    // Start API call and delay timer simultaneously
    const [data] = await Promise.all([
      postJSON('/recommend', { name, gender }),
      delay(DELAYS.nameGeneration) // Minimum 2 seconds
    ]);

    // Update message before showing results
    showLoading(true, 'Creating your Korean names...');
    await delay(500); // Brief pause

    if (data.success) {
      currentData.recommendations = data.names;
      displayNameCards(data.names);
      showLoading(false);
      showScreen('selection-screen');
      showToast('Recommendations ready ‚ú®');
    } else {
      showLoading(false);
      const errMsg = data.error?.message || data.error || 'Failed to get recommendations.';
      showToast(`Error: ${errMsg}`);
    }
  } catch (error) {
    showLoading(false);
    console.error('Recommendation error:', error);
    showToast('Connection issue ‚Äì please try again.');
  }
}

/* ==== Name selection with romanization + DELAY ==== */

function displayNameCards(names) {
  const container = document.getElementById('name-cards');
  if (!container) return;

  container.innerHTML = '';

  const categoryPalette = {
    Strength: '#234B7A',
    Light: '#6C8CC9',
    Honor: '#BD6B5F',
    Wisdom: '#4E6FA6',
    Justice: '#233A58',
    Love: '#C27A7A',
    Harmony: '#3A8570',
    Prosperity: '#C9A86A'
  };

  names.forEach((nameData, index) => {
    const card = document.createElement('div');
    card.className = 'name-card';
    card.dataset.index = index;

    card.setAttribute('role', 'button');
    card.setAttribute('aria-selected', 'false');
    card.setAttribute('aria-label', `${nameData.name} ‚Äì ${nameData.category}`);

    const categoryColor = categoryPalette[nameData.category] || '#234B7A';

    const romanization = Array.isArray(nameData.romanization) 
      ? nameData.romanization.join(' / ') 
      : (nameData.romanization || '');

    const romanizationHtml = romanization 
      ? `<span class="name-romanization">${romanization}</span>` 
      : '';

    card.innerHTML = `
      <div class="name-card-header">
        <div>
          <span class="korean-name">${nameData.name}</span>
          <span class="hanja">${nameData.hanja}</span>
          ${romanizationHtml}
        </div>
        <button class="btn-icon btn-pronounce" title="Hear pronunciation" onclick="event.stopPropagation(); pronounceName('${nameData.name}')">üîä</button>
      </div>
      <div class="name-meaning">${nameData.meaning}</div>
      <span class="name-category-badge" style="color:${categoryColor}; border-color:${categoryColor}33; background:${categoryColor}14;">
        ${nameData.category}
      </span>
    `;

    card.addEventListener('click', event => {
      createRipple(event, card);
      selectName(index);
    });

    container.appendChild(card);
  });
}

async function selectName(index) {
  if (index >= currentData.recommendations.length) return;

  highlightSelectedCard(index);
  currentData.selectedName = currentData.recommendations[index];
  saveToHistory(currentData.selectedName, currentData.originalName);

  // Show loading with custom message
  showLoading(true, 'Generating your fortune...');

  try {
    // Start API call and delay timer simultaneously
    const [data] = await Promise.all([
      postJSON('/select', { index }),
      delay(DELAYS.fortuneGeneration) // Minimum 1.5 seconds
    ]);

    // Update message
    showLoading(true, 'Reading the stars...');
    await delay(400);

    if (data.success) {
      currentData.fortune = data.fortune;
      showLoading(false);
      displayResult(currentData.selectedName);
      showScreen('result-screen');
      showToast('Name locked in! üåø');
    } else {
      showLoading(false);
      const errMsg = data.error?.message || data.error || 'Failed to process selection.';
      showToast(`Error: ${errMsg}`);
    }
  } catch (error) {
    showLoading(false);
    console.error('Selection error:', error);
    showToast('Something went wrong. Try again?');
  }
}

function highlightSelectedCard(index) {
  document.querySelectorAll('.name-card').forEach(card => {
    card.classList.remove('selected');
    card.setAttribute('aria-selected', 'false');
  });
  const selectedCard = document.querySelector(`.name-card[data-index="${index}"]`);
  if (selectedCard) {
    selectedCard.classList.add('selected');
    selectedCard.setAttribute('aria-selected', 'true');
  }
}

function displayResult(nameData) {
  const nameLarge = document.getElementById('korean-name-large');
  const nameHanja = document.getElementById('korean-name-hanja');
  const nameRomanization = document.getElementById('korean-name-romanization');
  const meaningText = document.getElementById('name-meaning-text');
  const categoryText = document.getElementById('name-category');
  const originalName = document.getElementById('original-name-display');

  if (nameLarge) nameLarge.textContent = nameData.name;
  if (nameHanja) nameHanja.textContent = nameData.hanja;
  if (meaningText) meaningText.textContent = nameData.meaning;
  if (categoryText) categoryText.textContent = nameData.category;
  if (originalName) originalName.textContent = currentData.originalName;

  if (nameRomanization) {
    const romanization = Array.isArray(nameData.romanization) 
      ? nameData.romanization.join(' / ') 
      : (nameData.romanization || '');
    nameRomanization.textContent = romanization;
  }

  updateResultButtons(nameData);
}

function updateResultButtons(nameData) {
  const actionsContainer = document.querySelector('#result-screen .result-actions');
  if (!actionsContainer) return;

  let favoriteBtn = actionsContainer.querySelector('.btn-favorite');
  let shareBtn = actionsContainer.querySelector('.btn-share');
  let pronounceBtn = actionsContainer.querySelector('.btn-pronounce-result');

  if (!favoriteBtn) {
    favoriteBtn = document.createElement('button');
    favoriteBtn.className = 'btn btn-secondary btn-favorite';
    actionsContainer.insertBefore(favoriteBtn, actionsContainer.firstChild);
  }

  if (!shareBtn) {
    shareBtn = document.createElement('button');
    shareBtn.className = 'btn btn-secondary btn-share';
    shareBtn.textContent = 'üì§ Share';
    shareBtn.onclick = () => shareName(currentData.selectedName);
    actionsContainer.insertBefore(shareBtn, favoriteBtn.nextSibling);
  }

  if (!pronounceBtn) {
    pronounceBtn = document.createElement('button');
    pronounceBtn.className = 'btn btn-secondary btn-pronounce-result';
    pronounceBtn.textContent = 'üîä Pronounce';
    pronounceBtn.onclick = () => pronounceName(currentData.selectedName.name);
    actionsContainer.insertBefore(pronounceBtn, shareBtn.nextSibling);
  }

  const isFav = isFavorite(nameData);
  favoriteBtn.textContent = isFav ? '‚≠ê Favorited' : '‚òÜ Favorite';
  favoriteBtn.onclick = () => {
    if (isFavorite(nameData)) {
      removeFromFavorites(nameData);
    } else {
      addToFavorites(nameData);
    }
    updateResultButtons(nameData);
  };
}

/* ==== Fortune flow ==== */

function showFortune() {
  if (currentData.fortune && currentData.fortune.length > 0) {
    displayFortune(currentData.fortune);
    showScreen('fortune-screen');
    showToast('Daily fortune revealed ‚òÄÔ∏è');
  }
}

function displayFortune(fortunes) {
  const container = document.getElementById('fortune-cards');
  if (!container) return;

  container.innerHTML = '';

  const fortuneStyles = {
    Love: { color: '#BD6B5F', icon: '‚ô•' },
    Career: { color: '#234B7A', icon: 'üíº' },
    Wealth: { color: '#C9A86A', icon: '‚óÜ' },
    Health: { color: '#3A8570', icon: '‚úß' },
    Wisdom: { color: '#4E6FA6', icon: '‚ú¶' },
    Family: { color: '#6C8CC9', icon: 'üè†' },
    Friendship: { color: '#C27A7A', icon: 'ü§ù' },
    Travel: { color: '#3A8570', icon: '‚úàÔ∏è' },
    Creativity: { color: '#BD6B5F', icon: 'üé®' },
    Luck: { color: '#C9A86A', icon: 'üçÄ' }
  };

  fortunes.forEach(fortune => {
    const style = fortuneStyles[fortune.category] || { color: '#234B7A', icon: '‚ú∂' };
    const card = document.createElement('div');
    card.className = 'fortune-card';
    card.style.borderLeft = `4px solid ${style.color}`;

    let messageEn = '';
    let messageKo = '';

    if (typeof fortune.message === 'object' && fortune.message !== null) {
      messageEn = fortune.message.en || '';
      messageKo = fortune.message.ko || '';
    } else {
      messageEn = fortune.message || '';
    }

    const categoryDisplay = fortune.category_ko 
      ? `${fortune.category} / ${fortune.category_ko}`
      : fortune.category;

    card.innerHTML = `
      <div class="fortune-category" style="color:${style.color}">
        ${style.icon} ${categoryDisplay}
      </div>
      <div class="fortune-message">${messageEn}</div>
      ${messageKo ? `<div class="fortune-message-ko">${messageKo}</div>` : ''}
    `;

    container.appendChild(card);
  });
}

/* ==== Reset ==== */

function startOver() {
  currentData = {
    originalName: '',
    gender: 'male',
    recommendations: [],
    selectedName: null,
    fortune: []
  };

  const nameInput = document.getElementById('name');
  if (nameInput) nameInput.value = '';

  const maleRadio = document.querySelector('input[name="gender"][value="male"]');
  if (maleRadio) maleRadio.checked = true;

  screenHistory = ['welcome-screen'];
  showScreen('welcome-screen', { skipHistory: true });
  showToast('Reset complete.');
}

/* ==== Utilities ==== */

function createRipple(event, element) {
  const ripple = document.createElement('span');
  ripple.className = 'ripple';
  const rect = element.getBoundingClientRect();
  const size = Math.max(rect.width, rect.height);
  ripple.style.width = ripple.style.height = `${size}px`;

  const hasPointer = typeof event?.clientX === 'number' && typeof event?.clientY === 'number' && (event.clientX !== 0 || event.clientY !== 0);
  const left = hasPointer ? (event.clientX - rect.left - size / 2) : (rect.width / 2 - size / 2);
  const top = hasPointer ? (event.clientY - rect.top - size / 2) : (rect.height / 2 - size / 2);

  ripple.style.left = `${left}px`;
  ripple.style.top = `${top}px`;
  element.appendChild(ripple);
  setTimeout(() => ripple.remove(), 600);
}

function attachCardEnhancements() {
  document.querySelectorAll('.name-card').forEach(card => {
    card.setAttribute('tabindex', '0');
    card.addEventListener('keydown', event => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        card.click();
      }
    });
  });
}

function injectProgressRail() {
  if (document.querySelector('.progress-rail')) return;

  const container = document.querySelector('.container');
  if (!container) return;

  const rail = document.createElement('div');
  rail.className = 'progress-rail';
  rail.id = 'progress-rail';
  rail.setAttribute('role', 'tablist');
  rail.setAttribute('aria-label', 'Onboarding steps');

  stepOrder.forEach(stepId => {
    const stepEl = document.createElement('div');
    stepEl.className = 'progress-step';
    stepEl.dataset.step = stepId;
    stepEl.textContent = screenTitles[stepId];
    rail.appendChild(stepEl);
  });

  container.prepend(rail);
  updateProgressRail('welcome-screen');
}

function updateProgressRail(activeScreenId) {
  document.querySelectorAll('.progress-step').forEach(step => step.classList.remove('active'));
  const activeStep = document.querySelector(`.progress-step[data-step="${activeScreenId}"]`);
  if (activeStep) activeStep.classList.add('active');
}

function focusFirstField(screenId) {
  if (screenId === 'name-input-screen') {
    const input = document.getElementById('name');
    if (input) setTimeout(() => input.focus(), 220);
  }
}

function injectToast() {
  if (document.querySelector('.toast')) return;
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.id = 'toast';
  toast.setAttribute('role', 'status');
  toast.setAttribute('aria-live', 'polite');
  document.body.appendChild(toast);
}

let toastTimeout;
function showToast(message = '') {
  const toast = document.getElementById('toast');
  if (!toast) return;

  toast.textContent = message;
  toast.classList.add('show');
  clearTimeout(toastTimeout);
  toastTimeout = setTimeout(() => toast.classList.remove('show'), 2600);
}

/* Keyboard support */
document.addEventListener('keydown', event => {
  if (event.key === 'Escape') {
    const currentScreen = screenHistory[screenHistory.length - 1];
    const backButton = document.querySelector(`#${currentScreen} .back-button`);
    if (backButton) backButton.click();
  }
});
